<?php

namespace Autoframe\Database\Orm\Blueprint;

class AfrTableBlueprint implements AfrOrmBlueprintInterface
{
    use AfrBlueprintUtils;


    public static function tableBlueprint(array $aToMerge = []): array
    {
        return AfrDbBlueprint::mergeBlueprint([


            static::CON_ALIAS => null,
            static::DB_NAME => null,

            static::TBL_NAME => null, // MANDATORY
            static::PREFER_DB_NAME => null, //original db name from show create table

            static::COLUMNS => [],

            //will be stored in comments if possible
            static::AFR_META => static::metaTblBlueprint(
                $aToMerge[static::AFR_META] ?? []
            ),

            //TBL PROPS:
            static::IF_NOT_EXIST => null,
            static::ENGINE => null, //or equivalent in other databases
            static::AUTOINCREMENT => null,
            static::PRIMARY_KEY => null,
            static::UNIQUE_KEYS => null,
            static::FULLTEXT_KEYS => null,
            static::KEYS => null,
            static::CONSTRAINTS => null,
            static::CHARSET => null,
            static::COLLATION => null,
            static::COMMENT => null,

        ],$aToMerge);
    }

    public static function metaTblBlueprint(array $aToMerge = []):array
    {
        return self::mergeBlueprint([
            static::BLUEPRINT_VERSION => null, //usefully in vendor
            static::BLUEPRINT_SOURCE => null, //provenance like: vendor, db, migrationClass, local, overwrite

            static::ENTITY_NAME => null, // recommended, or derived from TBL_NAME
            static::FQCN => null, // = NS\ENTITY_NAME; this must be autogenerated if imported from the db

            static::TBL_META_PIVOTS=>[],//[PIVOT_TABLE_NAME=>static::getAfrMetaBlueprintPivot()],
            static::M_USE_CACHE=>null,  //will be stored in the cache
            static::M_UPDATE_READONLY=>null, //not updatable


            //How many times the entry can be accessed before rehydrate
            // - After first data read, the ram box can usually be cleared
            // - This value is decremented -- and the data unsetted if counter === 0
            // - For reusable data like current logged-in user or session, use big integers
            // - For indefinite keep while process is alive, set to negative value.
            static::M_RAM_BOX_ACCESS_PERSISTENCE => 1,

        ],$aToMerge);
    }

    public static function metaPivotBlueprint(array $aToMerge = []):array
    {
        return self::mergeBlueprint([ // static::FK_RELATIONSHIP =>'N-N',//predefined N-N only for N-N relationships

            static::PIVOT_FQCN=>null,//mandatory or generated from PIVOT_TABLE_NAME

            static::PIVOT_TABLE_NAME=>null, //if null, assumed implode('_',natsort([FK_TBL_NAME,this.TBL_NAME])).'_pivot'
            static::PIVOT_COL_FOREIGN_SELF_KEY=>null, //mandatory NOT NULL column from this table
            static::PIVOT_COL_OWNER_TARGET_KEY=>null,//if null, assumed FK_TBL_NAME.'_'.FK_COL.colName

            static::PIVOT_METHOD=>null,//mandatory auto-naming. returns array of FK_FQCN or object or null :)
            static::FK_FQCN=>null,//mandatory or replaceable with tbl, dbNane, conn alias

            static::FK_COL=>null, //if null, assumed as fk table primary key
            static::FK_TBL_NAME=>null, //mandatory
            static::FK_DB_NAME=>null, //if null, assumed this db; sqlite will have empty string dbName ''
            static::CON_ALIAS=>null,//if null, assumed this connection
        ],$aToMerge);
    }








    protected static function metaColumnBlueprint(array $aToMerge = []):array
    {
        // 1-N  [Brand.id has Foreign Key Product.brand_id] a brand can manufacture many products
        // N-1  [Product.brand_id has Foreign Key Brand.id] products can be manufactured by a single brand
        //foreignIdFor(CLASS)
        //col->foreignIdFor(CLASS,col|prop)
        //col->foreignId('col')->constrained(othertbl.col)
        //classObj->foreign('col')->refferences(othertbl.col)
        //classObj->foreign('col')->refferences(col)->on(othertbl)
        //        return $this->belongsTo(Location::class, 'location_id', 'id');
        return self::mergeBlueprint([

            static::FK_RELATIONSHIP => null,//mandatory for foreign keys 1-1,1-N,N-1, NOT pivots[N-N]
            //if relationship target is 1, then the method returns one object, else returns array of objects
            static::FK_METHOD => null,//if null, defaults to col name this table column


            static::FK_FQCN => null,//mandatory or autogenerated or needed for autocomplete object return type or generated
            //if FK_FQCN is null, then we autogenerate this class from
            static::FK_TBL_NAME => null, //mandatory
            static::FK_COL => null, //if null, assumed as fk table primary key
            static::FK_DB_NAME => null, //if null, assumed this db; sqlite will have empty string dbName ''
            static::CON_ALIAS => null,//if null, assumed this connection


            static::M_LAZY_HYDRATE => null,  //fetched on access / demand, but this will be cached
            static::M_USE_CACHE => null,  //individual cache flag in the table cache is set to true
            static::M_HIDDEN => null, //not fetch able, not shown as property
            static::M_UPDATE_READONLY => null, //not updatable

        ],$aToMerge);
    }



}